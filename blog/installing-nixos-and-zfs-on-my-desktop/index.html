<!DOCTYPE html>
<html lang="en">

<head>
    <title>Installing NixOS and ZFS on my Desktop | Ivan Petkov</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://ipetkov.dev/style.css">
    <link rel="stylesheet" href="https://ipetkov.dev/color/green.css">

        <link rel="stylesheet" href="https://ipetkov.dev/color/background_blue.css">
    
    <link rel="stylesheet" href="https://ipetkov.dev/font-hack-subset.css">

        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://ipetkov.dev/rss.xml">
    <meta property="og:title" content="Installing NixOS and ZFS on my Desktop">
<meta property="og:site_name" content="ipetkov.dev">
<meta property="og:image" content="https://ipetkov.dev/favicon.png">
<meta property="og:image:type" content="image/png">
<meta property="og:image:alt" content="ipetkov.dev favicon">
<meta property="og:url" content="https://ipetkov.dev/blog/installing-nixos-and-zfs-on-my-desktop/">
<meta property="og:description" content="A walk through how I went about installing NixOS on my desktop.">
<meta property="og:type" content="article">
<link rel="icon" type="image/png" href="https://ipetkov.dev/favicon.png">
<link rel="stylesheet" href="https://ipetkov.dev/overrides.css">
<link rel="me" href="https://hachyderm.io/@ivan">
<link rel="alternate" type="application/atom+xml" title="Ivan Petkov" href="https://ipetkov.dev/atom.xml"></head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://ipetkov.dev" style="text-decoration: none;">
                    <div class="logo">
                      ipetkov.dev
                    </div>
                </a>
            </div>
        </div>

        
        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://ipetkov.dev">home</a></li>
            
                <li><a href="https://ipetkov.dev/about">about</a></li>
            
                <li class="active"><a href="https://ipetkov.dev/blog">blog</a></li>
            
                <li><a href="https://ipetkov.dev/tags">tags</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://ipetkov.dev/blog/installing-nixos-and-zfs-on-my-desktop/">Installing NixOS and ZFS on my Desktop</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2021-01-24
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://ipetkov.dev/tags/nixos/">#NixOS</a>&nbsp;
                <a class="post-tag" href="https://ipetkov.dev/tags/zfs/">#zfs</a></span>
    

        
        <div class="post-content">
            <p><em>This write up was originally published within my
<a rel="nofollow noreferrer" href="https://github.com/ipetkov/dotfiles/blob/fdb4df76ca2b031f4dcc668f6a8b58edb1948a52/docs/machine_init.md">dotfiles</a></em>.</p>
<p>NixOS is a great tool for declaratively managing system configurations (namely
what packages and other config files are available), but there are still a
number of imperative steps to run when setting up a brand new machine before
installation. (Okay, there <em>are</em> some projects which seek to automate this
process as well, but unless you are constantly (re-)provisioning new machines,
it is probably overkill...). There's a number of available tutorials and guides
on how to prepare a machine for NixOS installation, but I found all of them to
be incredibly basic (e.g.  set up single ext4 partition and move on), or didn't
quite fit the requirements I was imposing.</p>
<p>Since this was also my first "real" Linux install, there were a number of things
I was unsure of and had to research on my own to figure out whether it was
relevant or what configurations to choose. Here I document all the steps I went
through, along with (an attempt!) to capture my assumptions and deliberate
decisions so that whether I got something wrong, it stops being correct in the
future, or you simply disagree with my choices, it becomes easy to spot where to
stray and where to follow this guide.</p>
<span id="continue-reading"></span><h2 id="acknowledgements">Acknowledgements</h2>
<p>Huge thanks to <a rel="nofollow noreferrer" href="https://grahamc.com">Graham Christensen</a> whose blog posts were
my main inspiration and guide for installation:</p>
<ul>
<li><a rel="nofollow noreferrer" href="https://web.archive.org/web/20190831102758/https://grahamc.com/blog/nixos-on-dell-9560">NixOS on a Dell 9560</a></li>
<li><a rel="nofollow noreferrer" href="https://web.archive.org/web/20200621003223/https://grahamc.com/blog/nixos-on-zfs">ZFS Datasets for NixOS</a></li>
<li><a rel="nofollow noreferrer" href="https://web.archive.org/web/20201124122057/https://grahamc.com/blog/erase-your-darlings">Erase your darlings</a></li>
</ul>
<h2 id="assumptions-and-requirements">Assumptions and Requirements</h2>
<p>Below is a quick summary of the assumptions and requirements I had for the
system to provide some historical context and keep the rest of the guide
focused on running each step.</p>
<p>The installation was done in early December of 2020 on a brand new 1 TiB SSD.
The disk has four partitions, and here is the final result:</p>
<ol>
<li>A 1 GiB unencrypted boot partition (more on this later). I chose 1 GiB
because I've been bitten by having too small of a boot partition in the
past, and it will be a headache to try to resize the partition if it turns
out too small. Most people recommend using 300-500 MiB, but since I have
plenty of storage to spare I decided to use 1 GiB and forget about it (note
that every NixOS generation adds links in this partition, so having too
many generations laying around can fill it up as well).</li>
<li>A 32 MiB LUKS encrypted partition which contains the key for the remaining
partitions. I forget exactly why I went with 32 MiB exactly, but I wanted
to make this partition large enough to handle any LUKS upgrades or extra
key configurations, and I have space to spare (I think the LUKS2 max header
size is 4 MiB, and most people recommend having a partition about this big
plus some space for the actual key).</li>
<li>A 32 GiB swap partition because this machine has 16 GiB of RAM and I left
some headroom in case I upgrade it. I don't plan on enabling swap (to avoid
wearing out my SSD), but I made the partition anyway in case I change my
mind.</li>
<li>The remainder of the disk is managed by ZFS split into the following
datasets:
<ul>
<li><code>/local</code> - dataset for mounting <code>/nix/store</code>. It is not snapshotted since
the nix store can be trivially repopulated/rebuilt if the data is lost or
corrupted</li>
<li><code>/reserved</code> - A 100 GiB reserved partition to act as an over-provisioning
guard and preserve the SSD performance (SSDs avoid wearing out individual
blocks by moving writes around. But if the drive fills up, the speed and
health of the drive will decrease. By never mounting this dataset, and
asking ZFS to ensure there is always 100 GiB available for it, I'm
effecitvely capping the disk at 90%).</li>
<li><code>/system</code> - dataset for mounting <code>/root</code> and <code>/var</code>. This dataset is
regularly snapshotted so I can rollback in case something catastrophic
happens. I have not yet decided to <a rel="nofollow noreferrer" href="https://grahamc.com/blog/erase-your-darlings">erase my
darlings</a> but if I do I
would move my <code>/root</code> mount...</li>
<li><code>/user</code> - dataset for storing user home directories, regularly
snapshotted</li>
</ul>
</li>
</ol>
<h3 id="why-zfs">Why ZFS?</h3>
<p>I had generally heard good things about it, namely that it's a stable file
system implementation which supports efficient snapshots, rollbacks, and data
exports. I briefly looked into btrfs which also supports very similar
features, but the NixOS support (at the time) was lacking, and since I had
not previously used neither btrfs nor zfs, I went with the latter since I
expected the experience to be smoother.</p>
<h3 id="what-about-ssd-over-provisioning">What about SSD over-provisioning?</h3>
<p>SSDs are made up of flash storage which supports a (large, but) finite number
of write operations before the medium begins to degrade. The SSD controller
performs wear leveling by effectively writing new data in a new location by
transparently remapping the block identifier to the new location. This
requires having some free space on the disk to "move" the blocks around. If
the disk fills up, the controller will be forced to do subsequent writes in
the same spot.</p>
<p>Over-provisioning is a name that storage vendors give to the concept of
reserving some storage capacity to avoid accidentally filling it up and
degrading performance. Some vendors state that their modern products
automatically achieve this in their firmware without any manual intervention
(maybe the drive itself has more storage than advertised?). Other vendors
peddle special tools like Samsung Data Magician (which simply creates an empty
partition) to achieve the task.</p>
<p>Since I have lots of storage to spare on my 1 TiB drive, I decided to
over-provision 10% of its capacity by creating a reserved ZFS pool which I
will never mount. I can easily remove or shrink that reservation if needed, so
this seemed like a sensible choice.</p>
<h3 id="why-an-unencrypted-boot-partition">Why an unencrypted boot partition?</h3>
<p>Ultimately, you have to trust some piece of software somewhere to take your
keyboard input and unlock the disk without leaking the key somehow. An
unencrypted boot partition means someone who gets access to the disk can put a
compromised boot loader that can steal the key. Using an encrypted boot
partition avoids this risk, but that means that the UEFI implementation needs
to do the decryption, and someone who can access it could flash a compromised
implementation which also steals the key. A solution to that can be to use
Secure boot/Trusted boot but now we have to trust that the hardware itself
isn't compromised with some other back-door... It's turtles all the way down.</p>
<p>My threat model does not include someone physically accessing my machine, so
an unencrypted boot partition works fine for me. Setting up a trusted boot
sequence sounds interesting, but it's a project for another time.</p>
<h3 id="why-luks-and-not-native-zfs-encryption">Why LUKS and not native-ZFS encryption?</h3>
<p>I chose to go with using LUKS to encrypt the entire disk and run ZFS from
within it. LUKS has been around for a while and there is plenty of
tooling/documentation/guides around it, so it seemed like a safe approach.</p>
<p>ZFS apparently supports natively encrypting the disk, which avoids some double
indirection when trimming SSD blocks (and then having the decryption mapper
propagate those to the device). There are some potential security concerns
(like leaking dataset names/sizes and dedup tables), but none of them are
within my threat model. What really convinced me against using native-ZFS
encryption was the impression that the feature was somewhat newer, and I
didn't want to risk having it eat my laundry...</p>
<h3 id="why-use-the-allowdiscards-flag-with-luks">Why use the <code>allowDiscards</code> flag with LUKS?</h3>
<p>The <code>allowDiscards</code> option instructs the mapper to propagate trim commands
issued by the underlying filesystem, which allows the SSD to better perform
wear leveling. This option is disabled by default since there are some
theoretical attack vectors from having it enabled (namely leaking which blocks
are trimmed, an some potential oracle attacks if the attacker can influence
what data is written to the disk).</p>
<p>Since this doesn't fit my threat model (namely someone gaining physical access
to my disk) and since I am more worried about maintaining my SSD performance,
I decided to enable this option.</p>
<h2 id="installation">Installation</h2>
<p>On to the good stuff, actual installation steps start here! Note all commands
should be run as root.</p>
<h3 id="installer-preparation">Installer preparation</h3>
<ol>
<li><a rel="nofollow noreferrer" href="https://nixos.org/download.html">Download an installer</a> and burn it to a
bootable USB drive. Worth noting that if you already have an existing nix
install you can create your own custom installer (e.g. if you're a power
user or you need specific tools available during installation), but the
base installer should cover all the bases.</li>
<li>If there is an existing Windows installation on this machine (even if it is
on an entirely separate drive), consider <a rel="nofollow noreferrer" href="https://askubuntu.com/questions/1291758/ubuntu-20-04-and-fenvi-ax200-wifi-bluetooth-card-drivers-or-soolution-to-wifi">turning off the "Enable fast
startup" option</a>
and rebooting before continuing. I had to do this to get my bluetooth/wifi
(AX200) adapter to work (yay Windows hacks to gain speedup!).</li>
<li>(Optional) if you have other drives in the machine, consider unplugging
them to avoid accidentally overwriting the wrong disk due to a typo...</li>
<li>Plug in the USB, reboot the computer, hit the appropriate keys during the
BIOS, and boot into the USB</li>
</ol>
<h3 id="partitioning-the-disk">Partitioning the Disk</h3>
<ol>
<li>
<p>If a graphical installer image was used, it should drop us in a desktop
environment which should set up some basic stuff like networking. The rest
of the commands all need root privileges, so open a terminal and switch to
root to avoid having to prefix everything with <code>sudo</code>.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">sudo</span><span> su
</span></code></pre>
</li>
<li>
<p>Next, we need to figure out which disk we want to use.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">ls</span><span> /dev
</span></code></pre>
</li>
<li>
<p>In my case this is my second NVMe in this machine so I will be using
<code>nvme1n1</code>, but you may see a different number based on what is connected.
We'll store this in a variable to make it easier to copy-paste other
commands, so <strong>make sure to replace the <code>...</code> with your selected drive</strong>:</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span>DISK</span><span style="color:#f29668;">=</span><span style="color:#c2d94c;">/dev/...
</span></code></pre>
</li>
<li>
<p>Next, it's time to partition the actual disk. I'm going to be creating the
following partitions:</p>
<ul>
<li>1 GiB (unencrypted) boot partition - for storing the initial boot files</li>
<li>32 MiB LUKS key partition - the key for the rest of the disk. This will be
encrypted with a password that we remember (and type in during boot)</li>
<li>32 GiB swap partition - for enabling system swap</li>
<li>The remainder of the drive will be our actual, usable, partition</li>
</ul>
<p>We're going to be using <code>gdisk</code> below, but if you know how to use another
disk partition program, feel free to use it instead.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">gdisk </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">&quot;
</span></code></pre>
<details>
  <summary>Click to expand!</summary>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>GPT fdisk (gdisk) version 1.0.5
</span><span>
</span><span>Partition table scan:
</span><span>  MBR: not present
</span><span>  BSD: not present
</span><span>  APM: not present
</span><span>  GPT: not present
</span><span>
</span><span>Creating new GPT entries in memory.
</span><span>
</span><span>Command (? for help): o
</span><span>This option deletes all partitions and creates a new protective MBR.
</span><span>Proceed? (Y/N): Y
</span><span>
</span><span>Command (? for help): n
</span><span>Partition number (1-128, default 1):
</span><span>First sector (34-1953525134, default = 2048) or {+-}size{KMGTP}:
</span><span>Last sector (2048-1953525134, default = 1953525134) or {+-}size{KMGTP}: +1G
</span><span>Current type is 8300 (Linux filesystem)
</span><span>Hex code or GUID (L to show codes, Enter = 8300): EF00
</span><span>Changed type of partition to &#39;EFI system partition&#39;
</span><span>
</span><span>Command (? for help): n
</span><span>Partition number (2-128, default 2): 2
</span><span>First sector (34-1953525134, default = 2099200) or {+-}size{KMGTP}:
</span><span>Last sector (2099200-1953525134, default = 1953525134) or {+-}size{KMGTP}: +32M
</span><span>Current type is 8300 (Linux filesystem)
</span><span>Hex code or GUID (L to show codes, Enter = 8300):
</span><span>Changed type of partition to &#39;Linux filesystem&#39;
</span><span>
</span><span>Command (? for help): c
</span><span>Partition number (1-2): 2
</span><span>Enter name: luks key
</span><span>
</span><span>Command (? for help): n
</span><span>Partition number (3-128, default 3):
</span><span>First sector (34-1953525134, default = 2164736) or {+-}size{KMGTP}:
</span><span>Last sector (2164736-1953525134, default = 1953525134) or {+-}size{KMGTP}: +32G
</span><span>Current type is 8300 (Linux filesystem)
</span><span>Hex code or GUID (L to show codes, Enter = 8300):
</span><span>Changed type of partition to &#39;Linux filesystem&#39;
</span><span>
</span><span>Command (? for help): c
</span><span>Partition number (1-3): 3
</span><span>Enter name: swap
</span><span>
</span><span>Command (? for help): n
</span><span>Partition number (4-128, default 4):
</span><span>First sector (34-1953525134, default = 69273600) or {+-}size{KMGTP}:
</span><span>Last sector (69273600-1953525134, default = 1953525134) or {+-}size{KMGTP}:
</span><span>Current type is 8300 (Linux filesystem)
</span><span>Hex code or GUID (L to show codes, Enter = 8300):
</span><span>Changed type of partition to &#39;Linux filesystem&#39;
</span><span>
</span><span>Command (? for help): c
</span><span>Partition number (1-4): 4
</span><span>Enter name: root
</span><span>
</span><span>Command (? for help): p
</span><span>Disk /dev/nvme1n1: 1953525168 sectors, 931.5 GiB
</span><span>Model: Samsung SSD 970 EVO Plus 1TB
</span><span>Sector size (logical/physical): 512/512 bytes
</span><span>Disk identifier (GUID): 22610B10-DB5F-467D-8B9E-ECD88878ABA5
</span><span>Partition table holds up to 128 entries
</span><span>Main partition table begins at sector 2 and ends at sector 33
</span><span>First usable sector is 34, last usable sector is 1953525134
</span><span>Partitions will be aligned on 2048-sector boundaries
</span><span>Total free space is 2014 sectors (1007.0 KiB)
</span><span>
</span><span>Number  Start (sector)    End (sector)  Size       Code  Name
</span><span>   1            2048         2099199   1024.0 MiB  EF00  EFI system partition
</span><span>   2         2099200         2164735   32.0 MiB    8300  luks key
</span><span>   3         2164736        69273599   32.0 GiB    8300  swap
</span><span>   4        69273600      1953525134   898.5 GiB   8300  root
</span><span>
</span><span>Command (? for help): w
</span><span>
</span><span>Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
</span><span>PARTITIONS!!
</span><span>
</span><span>Do you want to proceed? (Y/N): Y
</span><span>OK; writing new GUID partition table (GPT) to /dev/nvme1n1.
</span><span>The operation has completed successfully.
</span></code></pre>
</details>
</li>
</ol>
<h3 id="luks-setup">LUKS Setup</h3>
<ol>
<li>
<p>Now that the disk is partitioned, it's time to turn on encryption! First
we'll initialize our <code>cryptkey</code> partition and fill it with random data.
This will eventually become the key to decrypt our actual drive. Note that
<strong>this is the day-to-day password used to unlock the computer at boot</strong>.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">cryptsetup</span><span> luksFormat</span><span style="color:#f29718;"> --type</span><span> luks1 </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p2&quot;
</span><span style="color:#ffb454;">cryptsetup</span><span> luksOpen </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p2&quot;</span><span> cryptkey
</span><span style="color:#ffb454;">dd</span><span> if=/dev/urandom of=/dev/mapper/cryptkey bs=1024 status=progress
</span></code></pre>
</li>
<li>
<p>Next, we initialize the swap partition (which will share the same key
written to our <code>cryptkey</code> partition along with the rest of the drive). Note
that there is no backup key set for this partition, but there should never
be any reason to try to recover any data written in the swap in case the
<code>cryptkey</code> partition is damaged.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">cryptsetup</span><span> luksFormat</span><span style="color:#f29718;"> --type</span><span> luks1</span><span style="color:#f29718;"> --keyfile-size</span><span> 8192</span><span style="color:#f29718;"> --key-file</span><span> /dev/mapper/cryptkey </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p3&quot;
</span><span style="font-style:italic;color:#5c6773;"># Mount the partition after creation
</span><span style="color:#ffb454;">cryptsetup</span><span> luksOpen</span><span style="color:#f29718;"> --keyfile-size</span><span> 8192</span><span style="color:#f29718;"> --key-file</span><span> /dev/mapper/cryptkey </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p3&quot;</span><span> cryptswap
</span></code></pre>
</li>
<li>
<p>Now it's time to encrypt the rest of the drive. Note that first we'll
initialize the drive with a <em>backup passphrase</em>. Make this a strong
password (e.g. diceware) <strong>and write it down and store is someplace safe</strong>.
If the <code>cryptkey</code> partition becomes damaged, this will be the only way to
recover the data on the drive!</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="font-style:italic;color:#5c6773;"># Initialize with a passphrase
</span><span style="color:#ffb454;">cryptsetup</span><span> luksFormat</span><span style="color:#f29718;"> --type</span><span> luks1 </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p4&quot;
</span><span style="font-style:italic;color:#5c6773;"># Add the cryptkey partition as a keyfile for unlocking during boot
</span><span style="color:#ffb454;">cryptsetup</span><span> luksAddKey</span><span style="color:#f29718;"> --new-keyfile-size</span><span> 8192 </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p4&quot;</span><span> /dev/mapper/cryptkey
</span></code></pre>
</li>
<li>
<p>Finally, mount the root partition. <strong>Note the use of <code>--allow-discards</code>
which may be a security risk</strong>. Read about the choices and assumptions
above as to why I have chosen to use this flag, but feel free to omit it if
desired.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">cryptsetup</span><span> luksOpen</span><span style="color:#f29718;"> --keyfile-size</span><span> 8192</span><span style="color:#f29718;"> --key-file</span><span> /dev/mapper/cryptkey</span><span style="color:#f29718;"> --allow-discards </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p4&quot;</span><span> cryptroot
</span></code></pre>
</li>
<li>
<p>Note that some guides recommend filling the drive with random data before
doing the encryption to avoid leaking information about how big the drive
is and which blocks are encrypted, etc. I am going to omit this step since
I want to avoid wearing out my SSD,</p>
</li>
</ol>
<h3 id="filesystem-setup">Filesystem setup</h3>
<ol>
<li>
<p>Initialize the boot partition as vfat</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">mkfs.vfat </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p1&quot;
</span></code></pre>
</li>
<li>
<p>Initialize the swap partition</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">mkswap</span><span> /dev/mapper/cryptswap
</span></code></pre>
</li>
<li>
<p>Next, it's time to initialize zfs. Feel free to pick any pool name you want,
but consider keeping it unique if you manage other zfs pools elsewhere</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span>POOL</span><span style="color:#f29668;">=</span><span style="color:#c2d94c;">nvme-pool </span><span style="font-style:italic;color:#5c6773;"># change as desired
</span><span style="color:#ffb454;">zpool</span><span> create </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">&quot;</span><span> /dev/mapper/cryptroot
</span><span style="font-style:italic;color:#5c6773;"># autotrim enabled to maintain SSD performance
</span><span style="color:#ffb454;">zpool</span><span> set autotrim=on </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">&quot;
</span></code></pre>
</li>
<li>
<p>Create the desired root datasets (or mounts) in the pool. Note that at the
time of writing, using <code>mountpoint=legacy</code> is required for correct NixOS
interoperation.</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>zfs create -o compression=on -o mountpoint=legacy &quot;${POOL}/local&quot;
</span><span>zfs create -o compression=on -o mountpoint=legacy &quot;${POOL}/local/nix&quot;
</span><span>zfs create -o compression=on -o mountpoint=legacy &quot;${POOL}/system&quot;
</span><span>zfs create -o compression=on -o mountpoint=legacy &quot;${POOL}/user&quot;
</span><span>zfs create -o compression=on -o mountpoint=legacy &quot;${POOL}/reserved&quot;
</span></code></pre>
</li>
<li>
<p>Set a variable with the default username you wish to use which we'll use
for creating a home directory later</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span>MY_USER</span><span style="color:#f29668;">=</span><span style="color:#c2d94c;">...
</span></code></pre>
</li>
<li>
<p>Next, we create any child datasets. Note that the <code>acltype=posixacl</code> flag
is required wherever <code>/var</code> will be mounted, so that users can access their
own journal logs</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">zfs</span><span> create</span><span style="color:#f29718;"> -o</span><span> xattr=sa</span><span style="color:#f29718;"> -o</span><span> acltype=posixacl </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/system/var&quot;
</span><span>
</span><span style="color:#ffb454;">zfs</span><span> create </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/system/root&quot;
</span><span style="color:#ffb454;">zfs</span><span> create </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/user/home&quot;
</span><span style="color:#ffb454;">zfs</span><span> create </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/user/home/$</span><span>{MY_USER}</span><span style="color:#c2d94c;">&quot;
</span></code></pre>
</li>
<li>
<p>Set a quota and reservation on the <code>reserved</code> data set. This will ensure
that the disk always has the specified amount of space available, and since
we will never mount this partition, we're effectively saving some space
from never being written (i.e. over-provisioning the SSD to maintain its
performance)</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">zfs</span><span> set reservation=100G </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/reserved&quot;
</span><span style="color:#ffb454;">zfs</span><span> set quota=100G </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/reserved&quot; </span><span style="font-style:italic;color:#5c6773;"># ensure we can&#39;t accidentally write more than 100G to this partition
</span></code></pre>
</li>
<li>
<p>Next, we enable local snapshotting so that we can quickly recover past
state if something goes wrong. Note that we only need to snapshot user data
and the system root. Other easily-rebuilt partitions (like <code>local</code>) don't
need snapshotting enabled. Also note that the actual snapshot frequency
will be managed by our NixOS configuration</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">zfs</span><span> set com.sun:auto-snapshot=true </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/system&quot;
</span><span style="color:#ffb454;">zfs</span><span> set com.sun:auto-snapshot=true </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/user&quot;
</span></code></pre>
</li>
<li>
<p>Lastly, <em>mount everything</em>! If you forget to mount a zfs dataset to the
right place, then data may get written in the wrong place and fail during
boot!</p>
<ul>
<li>I made the mistake of forgetting to mount the <code>/nix/store</code> path on the
new drive. The installer happily filled the root partition with the data,
but when my configuration correctly mounted the right dataset during
boot, suddenly all the packages were missing!</li>
</ul>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="font-style:italic;color:#5c6773;"># Mount the root partition itself
</span><span style="color:#ffb454;">mount</span><span style="color:#f29718;"> -t</span><span> zfs </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/system/root&quot;</span><span> /mnt
</span><span>
</span><span style="font-style:italic;color:#5c6773;"># Make directory entries for the subsequent mounts
</span><span style="color:#ffb454;">mkdir</span><span style="color:#f29718;"> -p</span><span> /mnt/boot
</span><span style="color:#ffb454;">mkdir</span><span style="color:#f29718;"> -p</span><span> /mnt/nix
</span><span style="color:#ffb454;">mkdir</span><span style="color:#f29718;"> -p</span><span> /mnt/var
</span><span style="color:#ffb454;">mkdir</span><span style="color:#f29718;"> -p </span><span style="color:#c2d94c;">&quot;/mnt/home/$</span><span>{MY_USER}</span><span style="color:#c2d94c;">&quot;
</span><span>
</span><span style="font-style:italic;color:#5c6773;"># Mount the boot partition
</span><span style="color:#ffb454;">mount </span><span style="color:#c2d94c;">&quot;$</span><span>{DISK}</span><span style="color:#c2d94c;">p1&quot;</span><span> /mnt/boot
</span><span>
</span><span style="font-style:italic;color:#5c6773;"># Mount the rest of our zfs datasets
</span><span style="color:#ffb454;">mount</span><span style="color:#f29718;"> -t</span><span> zfs </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/local/nix&quot;</span><span> /mnt/nix
</span><span style="color:#ffb454;">mount</span><span style="color:#f29718;"> -t</span><span> zfs </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/system/var&quot;</span><span> /mnt/var
</span><span style="color:#ffb454;">mount</span><span style="color:#f29718;"> -t</span><span> zfs </span><span style="color:#c2d94c;">&quot;$</span><span>{POOL}</span><span style="color:#c2d94c;">/user/home/$</span><span>{MY_USER}</span><span style="color:#c2d94c;">&quot; &quot;/mnt/home/$</span><span>{MY_USER}</span><span style="color:#c2d94c;">&quot;
</span></code></pre>
</li>
</ol>
<h3 id="nixos-installation">NixOS installation</h3>
<ol>
<li>
<p>Finally it's time to get nix involved! Run the generation command below
and it should do a good job at auto-detecting any hardware and filesystem
configurations</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">nixos-generate-config</span><span style="color:#f29718;"> --root</span><span> /mnt
</span></code></pre>
</li>
<li>
<p>Edit the generated config in <code>/mnt/etc/nixos/configuration.nix</code>. If you're
new to NixOS, or missing your favorite editor/environment setup, consider
lightly tweaking the default config (e.g. turning on ssh, setting up
networking, etc.) to get things going and come back to flesh it out later.
But before we continue there are a few more things to double check:</p>
<ol>
<li>Make sure that the <code>initrd.luks.devices</code> are correctly configured. If
anything is missing, or the disk uuid is incorrect, <strong>carefully</strong> update
the config and double check everything</li>
<li>Also carefully note that the <code>cryptkey</code> declaration shows up before any
other partions which are unlocked by it!</li>
<li>Make sure to update the <code>keyFileSize</code> parameter to whatever was used
during initialization</li>
<li>Also make sure to set the <code>allowDiscards</code> flag if used above
(<strong>noting the security caveats from before</strong>)</li>
<li>Make sure that all filesystems are correctly mapped to their zfs data
sets.</li>
<li>Add any missing <code>boot.initrd.availableKernelModules</code>. For example, I
had to add <code>"amdgpu"</code> to fix some screen resolution issues during early
boot.</li>
<li>Add your default user and set their home directory</li>
</ol>
</li>
<li>
<p>Time to actually install NixOS now! After the initial install is done,
reboot and hope everything went well...</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">nixos-install
</span><span style="color:#ffb454;">reboot
</span></code></pre>
</li>
<li>
<p>If you got this far and were able to log in, congrats, you did it! A few
more things to consider doing:</p>
<ul>
<li>Change the password for your default user</li>
<li>Change the root password, or even better, lock the root account so no one
can log into it directly</li>
</ul>
</li>
</ol>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h"></span>
                <hr />
            </div>
            <div class="pagination__buttons">
                
                    <span class="button next">
                        <a href="https://ipetkov.dev/blog/building-with-sqlx-on-nix/">
                            <span class="button__text">Building with SQLx on Nix</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
  <footer class="footer">
    <div class="footer__inner">
      <div class="copyright">
        <span>© 
    2025
 Ivan Petkov</span>

        <span class="copyright-theme">
          <span class="copyright-theme-sep">:: </span>
          Theme based on <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
        </span>
      </div>
    </div>
  </footer>


</div>
</body>

</html>
